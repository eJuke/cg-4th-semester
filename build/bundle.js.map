{"version":3,"file":"bundle.js","sources":["webpack:///webpack/bootstrap 6f05f4727a1a3e7f9fd7","webpack:///app/index.js","webpack:///","webpack:///./style/main.scss","webpack:///app/lab-code/lab1.js","webpack:///app/lab-code/lab2.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://ejuke.github.io/cg-7th-semester/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6f05f4727a1a3e7f9fd7\n **/","//styles\r\nimport './style/main.scss';\r\n//js\r\n\r\n// import '../node_modules/react/dist/react.min.js';\r\n// import '../node_modules/react-dom/dist/react-dom.min.js';\r\n\r\nvar canvasID = 'canvas',\r\n\t\tcontrolsID = 'controls',\r\n\t\tLab1 = require ('./lab-code/lab1.js'),\r\n\t\tLab2 = require ('./lab-code/lab2.js'),\r\n\t\tlab = new Lab1(canvasID, controlsID);\r\n\r\nvar cpath = (window.location.toString() == 'https://ejuke.github.io/cg-7th-semester/') ? window.location.toString() : '/';\r\n\r\ndocument.body.onload = function(e){\r\n\tlab.prepare();\r\n\r\n\tlab.readShader(cpath+'app/shaders/lab1.frag');\r\n\tlab.readShader(cpath+'app/shaders/lab1.vert');\r\n\r\n}\r\n\r\ndocument.getElementById('change-lab-1').onclick = function(){changeLab(1);};\r\ndocument.getElementById('change-lab-2').onclick = function(){changeLab(2);};\r\n\r\nfunction clearRoot(){\r\n\tlab.destroy();\r\n\tlab = null;\r\n\tdocument.getElementById('root').innerHTML = '<div class=\"canvas-container\" id=\"canvas\"></div><div class=\"controls-container\" id=\"controls\"></div>';\r\n}\r\n\r\nfunction changeLab(number){\r\n\tclearRoot();\r\n\tswitch(number){\r\n\t\tcase 1: \r\n\t\t\tlab = Lab1(canvasID, controlsID);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tlab = Lab2(canvasID, controlsID);\r\n\t\t\tbreak;\r\n\t}\r\n}\n\n\n/** WEBPACK FOOTER **\n ** app/index.js\n **/","undefined\n\n\n/** WEBPACK FOOTER **\n ** \n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./style/main.scss\n ** module id = 1\n ** module chunks = 0\n **/","function lab1 (id, id2) {\r\n\t//init components\r\n\tthis.canvasId = id;\r\n\tthis.controlsId = id2;\r\n\tthis.webgl = null;\r\n\tthis.canvas = null;\r\n\tthis.VSHADER_SOURCE = this.FSHADER_SOURCE = null;\r\n\tthis.VSHADER = this.FSHADER = null;\r\n\r\n\t//data\r\n\tthis.pMatrix = mat4.create(), this.mvMatrix = mat4.create();\r\n\tthis.cubeXRotation = 30 * Math.PI / 180, this.cubeYRotation = 30 * Math.PI / 180, this.cubeZRotation = 0.0;\r\n}\r\n\r\n/*Чтение шейдеров*/\r\nlab1.prototype.readShader = function(filePath){\r\n\tvar shaderType = null;\r\n\tvar thisObject = this;\r\n\tif (filePath.search('.frag') != -1) shaderType = 'fragment';\r\n\tif (filePath.search('.vert') != -1) shaderType = 'vertex';\r\n\tvar request = new XMLHttpRequest();\r\n\trequest.onreadystatechange = function(){\r\n\t\tif (request.readyState === 4 && request.status !== 404) { \r\n\t\t\tthisObject.onReadShader(request.responseText, shaderType);\r\n\t\t}\r\n\t}\r\n\trequest.open('GET', filePath, true);\r\n\trequest.send();\r\n}\r\n\r\n/*Инициализация шейдеров после чтения*/\r\nlab1.prototype.onReadShader = function(fileString, shaderType){\r\n\tif (shaderType == 'vertex'){\r\n\t\tthis.VSHADER_SOURCE = fileString;\r\n\t\tthis.VSHADER = this.compileShaders(this.webgl, this.VSHADER_SOURCE, this.webgl.VERTEX_SHADER);\r\n\t}\r\n\telse if (shaderType == 'fragment'){\r\n\t\tthis.FSHADER_SOURCE = fileString;\r\n\t\tthis.FSHADER = this.compileShaders(this.webgl, this.FSHADER_SOURCE, this.webgl.FRAGMENT_SHADER);\r\n\t}\r\n\telse return null;\r\n\tif (this.VSHADER_SOURCE && this.FSHADER_SOURCE) {\r\n\t\tconsole.info('Shaders loaded');\r\n\t\tthis.execute();\r\n\t}\r\n}\r\n\r\n/*Компиляция шейдеров*/\r\nlab1.prototype.compileShaders = function(gl, shaderSrc, shaderType){\r\n\tvar shader = gl.createShader(shaderType);\r\n\tgl.shaderSource(shader, shaderSrc);\r\n\tgl.compileShader(shader);\r\n\r\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n\t\tconsole.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\r\n\t\treturn null;\r\n\t}\r\n\telse console.info('Shader compiled successful.');\r\n\treturn shader;\r\n}\r\n\r\n/*Подготовка документа к исполнению кода*/\r\nlab1.prototype.prepare = function(){\r\n\tvar canvasC = document.getElementById(this.canvasId);\r\n\tvar controlsC = document.getElementById(this.controlsId);\r\n\tcanvasC.innerHTML = '<canvas id=\"lab1\" width=\"600px\" height=\"600px\"></canvas>';\r\n\tthis.canvas = document.getElementById('lab1');\r\n\tvar names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n\tfor (var ii = 0; ii < names.length; ++ii) {\r\n\t\ttry {\r\n\t\t\tthis.webgl = this.canvas.getContext(names[ii]);\r\n\t\t} catch(e) {}\r\n\t\tif (this.webgl) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvar inputX = document.createElement('input');\r\n\tvar inputY = document.createElement('input');\r\n\tvar inputZ = document.createElement('input');\r\n\tvar labelX = document.createElement('label');\r\n\tvar labelY = document.createElement('label');\r\n\tvar labelZ = document.createElement('label');\r\n\r\n\tinputX.type = \"number\";\r\n\tinputY.type = \"number\";\r\n\tinputZ.type = \"number\";\r\n\tinputX.value = \"30\";\r\n\tinputY.value = \"30\";\r\n\tinputZ.value = \"0\";\r\n\tvar thisClass = this;\r\n\tinputX.onchange = inputX.onkeyup = inputX.onmouseup\r\n\t = function(){\r\n\t\tthisClass.cubeXRotation = thisClass.rotate(this.value);\r\n\t\tthisClass.drawScene(thisClass.webgl);\r\n\t};\r\n\tinputY.onchange = inputY.onkeyup = inputY.onmouseup\r\n\t = function(){\r\n\t\tthisClass.cubeYRotation = thisClass.rotate(this.value);\r\n\t\tthisClass.drawScene(thisClass.webgl);\r\n\t};\r\n\tinputZ.onchange = inputZ.onkeyup = inputZ.onmouseup\r\n\t = function(){\r\n\t\tthisClass.cubeZRotation = thisClass.rotate(this.value);\r\n\t\tthisClass.drawScene(thisClass.webgl);\r\n\t};\r\n\tinputX.id = \"angleX\";\r\n\tinputY.id = \"angleY\";\r\n\tinputZ.id = \"angleZ\";\r\n\tinputX.className = \"angle-input\";\r\n\tinputY.className = \"angle-input\";\r\n\tinputZ.className = \"angle-input\";\r\n\r\n\tlabelX.innerHTML = \"угол по оси X:  \";\r\n\tlabelY.innerHTML = \"угол по оси Y:  \";\r\n\tlabelZ.innerHTML = \"угол по оси Z:  \";\r\n\r\n\tcontrolsC.appendChild(labelX);\r\n\tcontrolsC.appendChild(inputX);\r\n\tcontrolsC.appendChild(labelY);\r\n\tcontrolsC.appendChild(inputY);\r\n\tcontrolsC.appendChild(labelZ);\r\n\tcontrolsC.appendChild(inputZ);\r\n}\r\n\r\nlab1.prototype.rotate = function(angle){\r\n\treturn angle * Math.PI / 180.0;\r\n}\r\n\r\n/*Инициализация шейдеров*/\r\nlab1.prototype.initShaders = function(gl){\r\n\tthis.shaderProgram = gl.createProgram();\r\n\tgl.attachShader(this.shaderProgram, this.VSHADER);\r\n\tgl.attachShader(this.shaderProgram, this.FSHADER);\r\n\tgl.linkProgram(this.shaderProgram);\r\n\r\n\tif(!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)){\r\n\t\tconsole.error('Unable to initialize the shader program.');\r\n\t}\r\n\r\n\tgl.useProgram(this.shaderProgram);\r\n\r\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"aVertexPosition\");\r\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\r\n\r\n\tthis.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"uPMatrix\");\r\n\tthis.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"uMVMatrix\");\r\n\tthis.shaderProgram.vertexColorAttribute = gl.getAttribLocation(this.shaderProgram, \"aVertexColor\");\r\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexColorAttribute);\r\n}\r\n\r\n/*Собственно, отрисовка контекста*/\r\nlab1.prototype.execute = function(){\r\n\tif (this.webgl) console.info('WebGL init successful');\r\n\telse {\r\n\t\tconsole.error('WebGL not initialized');\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis.webgl.viewportWidth = this.canvas.width;\r\n\tthis.webgl.viewportHeight = this.canvas.height;\r\n\t// установить в качестве цвета очистки буфера цвета черный, полная непрозрачность\r\n\tthis.webgl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n\t// включает использование буфера глубины\r\n\tthis.webgl.enable(this.webgl.DEPTH_TEST);\r\n\t// определяет работу буфера глубины: более ближние объекты перекрывают дальние\r\n\tthis.webgl.depthFunc(this.webgl.LEQUAL);\r\n\tthis.webgl.clear(this.webgl.COLOR_BUFFER_BIT|this.webgl.DEPTH_BUFFER_BIT);  \r\n\r\n\tthis.initShaders(this.webgl);\r\n\r\n\tthis.horizAspect = this.webgl.viewportHeight / this.webgl.viewportWidth;\r\n\tthis.initBuffers(this.webgl);\r\n\tthis.drawScene(this.webgl);\r\n}\r\n\r\n/*Инициализация буфера*/\r\nlab1.prototype.initBuffers = function(gl){\r\n\r\n\tthis.cubeVerticesBuffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesBuffer);\r\n\tthis.vertices = [\r\n\t\t// Передняя грань\r\n\t\t-1.0, -1.0,  1.0,\r\n\t\t 1.0, -1.0,  1.0,\r\n\t\t 1.0,  1.0,  1.0,\r\n\t\t-1.0,  1.0,  1.0,\r\n\r\n\t\t// Задняя грань\r\n\t\t-1.0, -1.0, -1.0,\r\n\t\t-1.0,  1.0, -1.0,\r\n\t\t 1.0,  1.0, -1.0,\r\n\t\t 1.0, -1.0, -1.0,\r\n\r\n\t\t// Верхняя грань\r\n\t\t-1.0,  1.0, -1.0,\r\n\t\t-1.0,  1.0,  1.0,\r\n\t\t 1.0,  1.0,  1.0,\r\n\t\t 1.0,  1.0, -1.0,\r\n\r\n\t\t// Нижняя грань\r\n\t\t-1.0, -1.0, -1.0,\r\n\t\t 1.0, -1.0, -1.0,\r\n\t\t 1.0, -1.0,  1.0,\r\n\t\t-1.0, -1.0,  1.0,\r\n\r\n\t\t// Правая грань\r\n\t\t 1.0, -1.0, -1.0,\r\n\t\t 1.0,  1.0, -1.0,\r\n\t\t 1.0,  1.0,  1.0,\r\n\t\t 1.0, -1.0,  1.0,\r\n\r\n\t\t// Левая грань\r\n\t\t-1.0, -1.0, -1.0,\r\n\t\t-1.0, -1.0,  1.0,\r\n\t\t-1.0,  1.0,  1.0,\r\n\t\t-1.0,  1.0, -1.0\r\n\t];\r\n\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\r\n\r\n\tthis.colors = [\r\n\t\t[1.0,  0.0,  0.0,  1.0],    // Front face: red\r\n\t\t[1.0,  1.0,  1.0,  1.0],    // Back face: white\r\n\t\t[0.0,  1.0,  0.0,  1.0],    // Top face: green\r\n\t\t[0.0,  0.0,  1.0,  1.0],    // Bottom face: blue\r\n\t\t[1.0,  1.0,  0.0,  1.0],    // Right face: yellow\r\n\t\t[1.0,  0.0,  1.0,  1.0]     // Left face: purple\r\n\t];\r\n\r\n\tthis.generatedColors = [];\r\n\r\n\tfor (var j=0; j<6; j++) {\r\n\t\tvar c = this.colors[j];\r\n\t\t\r\n\t\tfor (var i=0; i<4; i++) {\r\n\t\t\tthis.generatedColors = this.generatedColors.concat(c);\r\n\t\t}\r\n\t}\r\n\r\n\tthis.cubeVerticesColorBuffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesColorBuffer);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.generatedColors), gl.STATIC_DRAW);\r\n\t\r\n\tthis.cubeVerticesIndexBuffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeVerticesIndexBuffer);\r\n\r\n\t// Этот массив определяет каждую грань как два треугольника,\r\n\t// используя индексы в массиве вершин, чтобы определить позицию\r\n\t// каждого треугольника.\r\n\r\n\tthis.cubeVertexIndices = [\r\n\t\t0,  1,  2,      0,  2,  3,    // front\r\n\t\t4,  5,  6,      4,  6,  7,    // back\r\n\t\t8,  9,  10,     8,  10, 11,   // top\r\n\t\t12, 13, 14,     12, 14, 15,   // bottom\r\n\t\t16, 17, 18,     16, 18, 19,   // right\r\n\t\t20, 21, 22,     20, 22, 23    // left\r\n\t];\r\n\r\n\t// Теперь отправим массив элементов в GL\r\n\r\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.cubeVertexIndices), gl.STATIC_DRAW);\r\n}\r\n\r\n/*Отрисовка сцены*/\r\nlab1.prototype.drawScene = function(gl){\r\n\t//очистка canvas\r\n\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\t//установка viewport\r\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\r\n\r\n\tmat4.perspective(45, this.horizAspect, 0.1, 100.0, this.pMatrix);\r\n\t//создаем матрицу текущего состояния (изначально - единичная) model-view matrix\r\n\tmat4.identity(this.mvMatrix);\r\n\tmat4.translate(this.mvMatrix, [0.0, 0.0, -10.0]);\r\n\tmat4.rotate(this.mvMatrix, this.cubeXRotation, [1,0,0]);\r\n\tmat4.rotate(this.mvMatrix, this.cubeYRotation, [0,1,0]);\r\n\tmat4.rotate(this.mvMatrix, this.cubeZRotation, [0,0,1]);\r\n\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesBuffer);\r\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\r\n\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesColorBuffer);\r\n\tgl.vertexAttribPointer(this.shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);\r\n\r\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeVerticesIndexBuffer);\r\n\r\n\tthis.setMatrixUniforms(gl);\r\n\tgl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);\r\n}\r\n\r\n/*Перенос изменений матриц в видеокарту*/\r\nlab1.prototype.setMatrixUniforms = function(gl) {\r\n\tgl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);\r\n\tgl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);\r\n}\r\n\r\nlab1.prototype.destroy = function(){\r\n\tthis.webgl = null;\r\n\tthis.canvas = null;\r\n\tthis.VSHADER_SOURCE = this.FSHADER_SOURCE = null;\r\n\tthis.VSHADER = this.FSHADER = null;\r\n}\r\n\r\n/*Экспорт модуля*/\r\nmodule.exports = lab1;\n\n\n/** WEBPACK FOOTER **\n ** app/lab-code/lab1.js\n **/","function lab2(id, id2){\r\n\tthis.gl = null;\r\n}\r\n\r\nlab2.prototype.destroy = function(){\r\n\t\r\n}\r\n\r\nmodule.exports = lab2;\n\n\n/** WEBPACK FOOTER **\n ** app/lab-code/lab2.js\n **/"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;ACAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;;;;;AC1CA;;;;;;;;ACAA;AFCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AGjTA;AHCA;AACA;AACA;AACA;AACA;AAGA;;;","sourceRoot":""}