{"version":3,"file":"bundle.js","sources":["webpack:///webpack/bootstrap a830246e9f6344cf863d","webpack:///app/index.js","webpack:///","webpack:///./style/main.scss","webpack:///app/lab-code/lab1.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://ejuke.github.io/cg-7th-semester/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a830246e9f6344cf863d\n **/","//styles\nimport './style/main.scss';\n//js\n\n// import '../node_modules/react/dist/react.min.js';\n// import '../node_modules/react-dom/dist/react-dom.min.js';\n\nvar rootElementId = 'root',\n\t\tLab1 = require ('./lab-code/lab1.js'),\n\t\tlab1 = new Lab1(rootElementId);\n\nvar cpath = (window.location.toString() == 'https://ejuke.github.io/cg-7th-semester/') ? window.location.toString() : '/';\n\ndocument.body.onload = function(e){\n\tlab1.prepare();\n\n\tlab1.readShader(cpath+'app/shaders/lab1.frag');\n\tlab1.readShader(cpath+'app/shaders/lab1.vert');\n\n}\n\n\n/** WEBPACK FOOTER **\n ** app/index.js\n **/","undefined\n\n\n/** WEBPACK FOOTER **\n ** \n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./style/main.scss\n ** module id = 1\n ** module chunks = 0\n **/","function lab1 (id) {\n\t//init components\n\tthis.rootId = id;\n\tthis.webgl = null;\n\tthis.canvas = null;\n\tthis.VSHADER_SOURCE = this.FSHADER_SOURCE = null;\n\tthis.VSHADER = this.FSHADER = null;\n\n\t//data\n\tthis.pMatrix = mat4.create(), this.mvMatrix = mat4.create();\n\tthis.cubeXRotation = 0.0, this.cubeYRotation = 0.0, this.cubeZRotation = 0.0;\n}\n\n/*Чтение шейдеров*/\nlab1.prototype.readShader = function(filePath){\n\tvar shaderType = null;\n\tvar thisObject = this;\n\tif (filePath.search('.frag') != -1) shaderType = 'fragment';\n\tif (filePath.search('.vert') != -1) shaderType = 'vertex';\n\tvar request = new XMLHttpRequest();\n\trequest.onreadystatechange = function(){\n\t\tif (request.readyState === 4 && request.status !== 404) { \n\t\t\tthisObject.onReadShader(request.responseText, shaderType);\n\t\t}\n\t}\n\trequest.open('GET', filePath, true);\n\trequest.send();\n}\n\n/*Инициализация шейдеров после чтения*/\nlab1.prototype.onReadShader = function(fileString, shaderType){\n\tif (shaderType == 'vertex'){\n\t\tthis.VSHADER_SOURCE = fileString;\n\t\tthis.VSHADER = this.compileShaders(this.webgl, this.VSHADER_SOURCE, this.webgl.VERTEX_SHADER);\n\t}\n\telse if (shaderType == 'fragment'){\n\t\tthis.FSHADER_SOURCE = fileString;\n\t\tthis.FSHADER = this.compileShaders(this.webgl, this.FSHADER_SOURCE, this.webgl.FRAGMENT_SHADER);\n\t}\n\telse return null;\n\tif (this.VSHADER_SOURCE && this.FSHADER_SOURCE) {\n\t\tconsole.info('Shaders loaded');\n\t\tthis.execute();\n\t}\n}\n\n/*Компиляция шейдеров*/\nlab1.prototype.compileShaders = function(gl, shaderSrc, shaderType){\n\tvar shader = gl.createShader(shaderType);\n\tgl.shaderSource(shader, shaderSrc);\n\tgl.compileShader(shader);\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\tconsole.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n\t\treturn null;\n\t}\n\telse console.info('Shader compiled successful.');\n\treturn shader;\n}\n\n/*Подготовка документа к исполнению кода*/\nlab1.prototype.prepare = function(){\n\tvar rootEl = document.getElementById(this.rootId);\n\trootEl.innerHTML = '<canvas id=\"lab1\" width=\"600px\" height=\"600px\"></canvas>';\n\tthis.canvas = document.getElementById('lab1');\n\tvar names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n\tfor (var ii = 0; ii < names.length; ++ii) {\n\t\ttry {\n\t\t\tthis.webgl = this.canvas.getContext(names[ii]);\n\t\t} catch(e) {}\n\t\tif (this.webgl) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvar inputX = document.createElement('input');\n\tvar inputY = document.createElement('input');\n\tvar inputZ = document.createElement('input');\n\tvar labelX = document.createElement('label');\n\tvar labelY = document.createElement('label');\n\tvar labelZ = document.createElement('label');\n\n\tinputX.type = \"number\";\n\tinputY.type = \"number\";\n\tinputZ.type = \"number\";\n\tinputX.value = \"0.0\";\n\tinputY.value = \"0.0\";\n\tinputZ.value = \"0.0\";\n\tvar thisClass = this;\n\tinputX.onchange = function(){\n\t\tthisClass.cubeXRotation = thisClass.rotate(this.value);\n\t\tthisClass.drawScene(thisClass.webgl);\n\t};\n\tinputY.onchange = function(){\n\t\tthisClass.cubeYRotation = thisClass.rotate(this.value);\n\t\tthisClass.drawScene(thisClass.webgl);\n\t};\n\tinputZ.onchange = function(){\n\t\tthisClass.cubeZRotation = thisClass.rotate(this.value);\n\t\tthisClass.drawScene(thisClass.webgl);\n\t};\n\tinputX.id = \"angleX\";\n\tinputY.id = \"angleY\";\n\tinputZ.id = \"angleZ\";\n\tinputX.className = \"angle-input\";\n\tinputY.className = \"angle-input\";\n\tinputZ.className = \"angle-input\";\n\n\tlabelX.innerHTML = \"<br><br>угол по оси X:  \";\n\tlabelY.innerHTML = \"<br><br>угол по оси Y:  \";\n\tlabelZ.innerHTML = \"<br><br>угол по оси Z:  \";\n\n\trootEl.appendChild(labelX);\n\trootEl.appendChild(inputX);\n\trootEl.appendChild(labelY);\n\trootEl.appendChild(inputY);\n\trootEl.appendChild(labelZ);\n\trootEl.appendChild(inputZ);\n}\n\nlab1.prototype.rotate = function(angle){\n\treturn angle * Math.PI / 180.0;\n}\n\n/*Инициализация шейдеров*/\nlab1.prototype.initShaders = function(gl){\n\tthis.shaderProgram = gl.createProgram();\n\tgl.attachShader(this.shaderProgram, this.VSHADER);\n\tgl.attachShader(this.shaderProgram, this.FSHADER);\n\tgl.linkProgram(this.shaderProgram);\n\n\tif(!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)){\n\t\tconsole.error('Unable to initialize the shader program.');\n\t}\n\n\tgl.useProgram(this.shaderProgram);\n\n\tthis.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, \"aVertexPosition\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);\n\n\tthis.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"uPMatrix\");\n\tthis.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram, \"uMVMatrix\");\n\tthis.shaderProgram.vertexColorAttribute = gl.getAttribLocation(this.shaderProgram, \"aVertexColor\");\n\tgl.enableVertexAttribArray(this.shaderProgram.vertexColorAttribute);\n}\n\n/*Собственно, отрисовка контекста*/\nlab1.prototype.execute = function(){\n\tif (this.webgl) console.info('WebGL init successful');\n\telse {\n\t\tconsole.error('WebGL not initialized');\n\t\treturn false;\n\t}\n\n\tthis.webgl.viewportWidth = this.canvas.width;\n\tthis.webgl.viewportHeight = this.canvas.height;\n\t// установить в качестве цвета очистки буфера цвета черный, полная непрозрачность\n\tthis.webgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\t// включает использование буфера глубины\n\tthis.webgl.enable(this.webgl.DEPTH_TEST);\n\t// определяет работу буфера глубины: более ближние объекты перекрывают дальние\n\tthis.webgl.depthFunc(this.webgl.LEQUAL);\n\tthis.webgl.clear(this.webgl.COLOR_BUFFER_BIT|this.webgl.DEPTH_BUFFER_BIT);  \n\n\tthis.initShaders(this.webgl);\n\n\tthis.horizAspect = this.webgl.viewportHeight / this.webgl.viewportWidth;\n\tthis.initBuffers(this.webgl);\n\tthis.drawScene(this.webgl);\n}\n\n/*Инициализация буфера*/\nlab1.prototype.initBuffers = function(gl){\n\n\tthis.cubeVerticesBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesBuffer);\n\tthis.vertices = [\n\t\t// Передняя грань\n\t\t-1.0, -1.0,  1.0,\n\t\t 1.0, -1.0,  1.0,\n\t\t 1.0,  1.0,  1.0,\n\t\t-1.0,  1.0,  1.0,\n\n\t\t// Задняя грань\n\t\t-1.0, -1.0, -1.0,\n\t\t-1.0,  1.0, -1.0,\n\t\t 1.0,  1.0, -1.0,\n\t\t 1.0, -1.0, -1.0,\n\n\t\t// Верхняя грань\n\t\t-1.0,  1.0, -1.0,\n\t\t-1.0,  1.0,  1.0,\n\t\t 1.0,  1.0,  1.0,\n\t\t 1.0,  1.0, -1.0,\n\n\t\t// Нижняя грань\n\t\t-1.0, -1.0, -1.0,\n\t\t 1.0, -1.0, -1.0,\n\t\t 1.0, -1.0,  1.0,\n\t\t-1.0, -1.0,  1.0,\n\n\t\t// Правая грань\n\t\t 1.0, -1.0, -1.0,\n\t\t 1.0,  1.0, -1.0,\n\t\t 1.0,  1.0,  1.0,\n\t\t 1.0, -1.0,  1.0,\n\n\t\t// Левая грань\n\t\t-1.0, -1.0, -1.0,\n\t\t-1.0, -1.0,  1.0,\n\t\t-1.0,  1.0,  1.0,\n\t\t-1.0,  1.0, -1.0\n\t];\n\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n\n\tthis.colors = [\n\t\t[1.0,  1.0,  1.0,  1.0],    // Front face: white\n\t\t[1.0,  0.0,  0.0,  1.0],    // Back face: red\n\t\t[0.0,  1.0,  0.0,  1.0],    // Top face: green\n\t\t[0.0,  0.0,  1.0,  1.0],    // Bottom face: blue\n\t\t[1.0,  1.0,  0.0,  1.0],    // Right face: yellow\n\t\t[1.0,  0.0,  1.0,  1.0]     // Left face: purple\n\t];\n\n\tthis.generatedColors = [];\n\n\tfor (var j=0; j<6; j++) {\n\t\tvar c = this.colors[j];\n\t\t\n\t\tfor (var i=0; i<4; i++) {\n\t\t\tthis.generatedColors = this.generatedColors.concat(c);\n\t\t}\n\t}\n\n\tthis.cubeVerticesColorBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesColorBuffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.generatedColors), gl.STATIC_DRAW);\n\t\n\tthis.cubeVerticesIndexBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeVerticesIndexBuffer);\n\n\t// Этот массив определяет каждую грань как два треугольника,\n\t// используя индексы в массиве вершин, чтобы определить позицию\n\t// каждого треугольника.\n\n\tthis.cubeVertexIndices = [\n\t\t0,  1,  2,      0,  2,  3,    // front\n\t\t4,  5,  6,      4,  6,  7,    // back\n\t\t8,  9,  10,     8,  10, 11,   // top\n\t\t12, 13, 14,     12, 14, 15,   // bottom\n\t\t16, 17, 18,     16, 18, 19,   // right\n\t\t20, 21, 22,     20, 22, 23    // left\n\t];\n\n\t// Теперь отправим массив элементов в GL\n\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.cubeVertexIndices), gl.STATIC_DRAW);\n}\n\n/*Отрисовка сцены*/\nlab1.prototype.drawScene = function(gl){\n\tconsole.log(this.cubeXRotation, this.cubeYRotation, this.cubeZRotation);\n\t//очистка canvas\n\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\t//установка viewport\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\n\tmat4.perspective(45, this.horizAspect, 0.1, 100.0, this.pMatrix);\n\t//создаем матрицу текущего состояния (изначально - единичная) model-view matrix\n\tmat4.identity(this.mvMatrix);\n\tmat4.translate(this.mvMatrix, [0.0, 0.0, -10.0]);\n\tmat4.rotate(this.mvMatrix, this.cubeXRotation, [1,0,0]);\n\tmat4.rotate(this.mvMatrix, this.cubeYRotation, [0,1,0]);\n\tmat4.rotate(this.mvMatrix, this.cubeZRotation, [0,0,1]);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.cubeVerticesColorBuffer);\n\tgl.vertexAttribPointer(this.shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);\n\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cubeVerticesIndexBuffer);\n\n\tthis.setMatrixUniforms(gl);\n\tgl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);\n}\n\n/*Перенос изменений матриц в видеокарту*/\nlab1.prototype.setMatrixUniforms = function(gl) {\n\tgl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);\n\tgl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);\n}\n\n/*Экспорт модуля*/\nmodule.exports = lab1;\n\n\n/** WEBPACK FOOTER **\n ** app/lab-code/lab1.js\n **/"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;ACAA;AACA;AACA;ADEA;AACA;ACCA;AACA;AACA;AACA;AACA;AAEA;;;;;;ACnBA;;;;;;;;ACAA;AFCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;","sourceRoot":""}